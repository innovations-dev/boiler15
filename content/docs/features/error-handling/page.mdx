export const metadata = {
  title: "Error Handling",
  description: "Learn about error handling patterns in the boilerplate",
  section: "Features",
  order: 6,
};

# Error Handling

Our error handling approach focuses on providing clear feedback to users while maintaining type safety and proper error logging.

## Overview

- 🔒 **Type-Safe Errors**: Centralized error types and utilities
- 🌐 **API Error Handling**: Consistent error responses with status codes
- 🔄 **Query Error Management**: React Query error handling with toast notifications
- ✅ **Form Validation**: Zod schema validation with react-hook-form
- 🎯 **Error Boundaries**: Next.js error boundaries for graceful UI recovery
- 🚦 **Loading States**: Suspense boundaries with skeleton loaders

## Error Types

We maintain a set of type-safe error classes in `lib/query/error.ts`:

```typescript
export class ApiError extends Error {
  constructor(
    public statusCode: number,
    message: string
  ) {
    super(message);
    this.name = "ApiError";
  }
}

export class UnauthorizedError extends ApiError {
  constructor(message: string) {
    super(401, message);
    this.name = "UnauthorizedError";
  }
}

// Additional typed errors: ForbiddenError, NotFoundError, BadRequestError
```

## API Error Handling

We use a consistent pattern for handling API errors:

```typescript
// lib/api/error.ts
export const handleApiError = (error: unknown): Response => {
  console.error("API Error:", error);

  if (error instanceof ApiError) {
    return Response.json(
      { code: error.code, message: error.message },
      { status: error.status }
    );
  }

  if (error instanceof z.ZodError) {
    return Response.json(
      {
        code: "VALIDATION_ERROR",
        message: "Invalid request data",
        errors: error.errors,
      },
      { status: 400 }
    );
  }

  return Response.json(
    { code: "INTERNAL_ERROR", message: "Internal server error" },
    { status: 500 }
  );
};
```

## Query Error Handling

Our custom hooks handle query errors with proper error handling and toast notifications:

```typescript
// Example from hooks/organization/use-organizations.ts
export function useOrganizations() {
  return useQuery<Organization[]>({
    queryKey: queryKeys.organizations.list(),
    queryFn: async () => {
      const response = await getOrganizationsAction();
      if (response.error) {
        throw new Error(response.error.message);
      }
      return response.data ?? [];
    },
    meta: {
      onError: (error: Error) => {
        toast.error(`Failed to load organizations: ${error.message}`);
      },
    },
  });
}
```

## Form Validation

We use Zod with react-hook-form for type-safe form validation:

```typescript
// Example form validation
const createOrganizationSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  slug: z.string().min(2, "Slug must be at least 2 characters"),
});

export function CreateOrganizationForm() {
  const form = useForm<z.infer<typeof createOrganizationSchema>>({
    resolver: zodResolver(createOrganizationSchema),
  });

  return (
    <Form {...form}>
      <FormField
        control={form.control}
        name="name"
        render={({ field }) => (
          <FormItem>
            <FormLabel>Name</FormLabel>
            <FormControl>
              <Input {...field} />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />
    </Form>
  );
}
```

## Error Boundaries

We implement error boundaries at different levels:

### Global Error Boundary

```typescript
// app/global-error.tsx
export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div className="flex min-h-screen flex-col items-center justify-center">
      <div className="space-y-4 text-center">
        <h1 className="text-4xl font-bold">Something went wrong!</h1>
        <p className="text-muted-foreground">
          {error.message || "An error occurred. Please try again later."}
        </p>
        <Button onClick={() => reset()}>Try again</Button>
      </div>
    </div>
  );
}
```

### Route Error Boundaries

```typescript
// app/(admin)/admin/error.tsx
export default function OrganizationsError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error(error);
  }, [error]);

  return (
    <Alert variant="destructive">
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>Error loading organizations</AlertTitle>
      <AlertDescription className="flex items-center gap-x-2">
        An error occurred. Please try again.
        <Button variant="outline" size="sm" onClick={() => reset()}>
          Try again
        </Button>
      </AlertDescription>
    </Alert>
  );
}
```

## Loading States

We handle loading states with Suspense and skeleton components:

```typescript
export default function OrganizationsPage() {
  return (
    <div className="space-y-6">
      <Suspense fallback={<OrganizationsListSkeleton />}>
        <OrganizationsList />
      </Suspense>
    </div>
  );
}
```

## Best Practices

1. **Type Safety First**

   - Use typed error classes for different error scenarios
   - Implement type guards for error checking
   - Maintain consistent error response types

2. **Graceful Error Recovery**

   - Implement retry mechanisms for transient failures
   - Provide clear user feedback with recovery options
   - Use error boundaries for UI isolation

3. **Error Logging**

   - Log errors with appropriate context
   - Include error codes and stack traces
   - Maintain different log levels (info, warn, error)

4. **User Experience**

   - Show meaningful error messages
   - Provide recovery actions when possible
   - Handle loading states with skeleton loaders

5. **API Error Handling**
   - Use consistent error response format
   - Include appropriate HTTP status codes
   - Validate request data with Zod schemas

## Next Steps

- [Form Handling](/docs/features/forms) - Learn about form validation patterns
- [API Routes](/docs/features/api-routes) - API implementation patterns
- [Components](/docs/features/ui-components) - UI component patterns
