export const metadata = {
  title: "Query Patterns",
  description: "Common query patterns and data fetching strategies",
  section: "Features",
  order: 3,
};

# Query Patterns

Learn about common query patterns and data fetching strategies used in our Next.js 15 Boilerplate.

## Overview

We use [Tanstack Query](https://tanstack.com/query) (React Query) along with our Drizzle ORM setup for efficient data fetching and state management. Our implementation focuses on:

- üîí **Type Safety**: End-to-end type safety with Zod validation
- üéØ **Error Handling**: Consistent error handling with toast notifications
- üîÑ **Cache Management**: Intelligent cache invalidation strategies
- üìù **Logging**: Enhanced error logging with context
- üöÄ **Performance**: Optimistic updates and prefetching
- üõ°Ô∏è **Validation**: Runtime type checking with Zod schemas

## Query Client Configuration

Our query client is configured with sensible defaults in `app/_providers/query-client-provider.tsx`:

```tsx
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000, // 1 minute
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});
```

## Base Query Hooks

### Type-Safe API Queries

We use a base query hook that ensures type safety and consistent error handling:

```tsx
export function useApiQuery<T extends z.ZodType>(
  key: readonly unknown[],
  queryFn: () => Promise<z.infer<T>>,
  schema: T,
  options?: Omit<UseQueryOptions<z.infer<T>>, "queryKey" | "queryFn">
) {
  return useQuery<z.infer<T>>({
    queryKey: key,
    queryFn: async () => {
      try {
        const data = await queryFn();
        return schema.parse(data);
      } catch (error) {
        logError(error, `useApiQuery:${key.join(":")}`);
        errorLogger.log(error, ErrorSource.QUERY, {
          context: `useApiQuery:${key.join(":")}`,
        });
        throw error;
      }
    },
    meta: {
      onError: (error: unknown) => {
        const message = isQueryError(error)
          ? error.message
          : "An unexpected error occurred";
        toast.error(message);
      },
    },
    ...options,
  });
}
```

### Base Mutation Hook

Our base mutation hook provides consistent error handling and logging:

```tsx
export function useBaseMutation<TData, TError = unknown, TVariables = void>({
  mutationFn,
  onSuccess,
  onMutate,
  onError,
  errorMessage = "An error occurred",
  context = "mutation",
  options = {},
}: MutationConfig<TData, TError, TVariables>) {
  return useMutation({
    mutationFn: async (variables: TVariables) => {
      try {
        return await mutationFn(variables);
      } catch (error) {
        logError(error, `${context}:mutation`);
        errorLogger.log(error, ErrorSource.MUTATION, {
          code: "MUTATION_ERROR",
          context,
        });
        throw handleApiError(error);
      }
    },
    onSuccess,
    onError: (error) => {
      const message = error instanceof ApiError ? error.message : errorMessage;
      toast.error(message);
      onError?.(error);
    },
    ...options,
  });
}
```

## Server Components

Server components should directly use the database client for data fetching:

```tsx
// app/organizations/page.tsx
import { db } from "@/lib/db";
import { organizations } from "@/lib/db/schema";

export default async function OrganizationsPage() {
  const orgs = await db
    .select()
    .from(organizations)
    .orderBy(organizations.createdAt);

  return (
    <div>
      {orgs.map((org) => (
        <div key={org.id}>{org.name}</div>
      ))}
    </div>
  );
}
```

## Client Components

### Custom Query Hooks

We centralize query logic in custom hooks with proper typing and error handling:

```tsx
export function useOrganizations() {
  const queryClient = useQueryClient();

  // Prefetch on mount
  useEffect(() => {
    void queryClient.prefetchQuery({
      queryKey: queryKeys.organizations.list(),
      queryFn: async () => {
        const response = await getOrganizationsAction();
        return defaultResponse(response);
      },
    });
  }, [queryClient]);

  return useApiQuery(
    queryKeys.organizations.list(),
    async () => {
      const response = await getOrganizationsAction();
      return defaultResponse(response);
    },
    createApiResponseSchema(organizationSelectSchema.array()),
    {
      ...cacheConfig.queries.organization,
    }
  );
}
```

### Mutation Hooks

Handle data mutations with proper error handling, cache updates, and optimistic updates:

```tsx
export function useUpdateProfile() {
  const queryClient = useQueryClient();

  return useBaseMutation({
    mutationFn: async (data: UpdateProfileInput) => {
      try {
        return await authClient.updateUser(data);
      } catch (error) {
        throw handleApiError(error);
      }
    },
    onMutate: async (newData) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({
        queryKey: queryKeys.sessions.current(),
      });

      // Snapshot previous value
      const previousData = queryClient.getQueryData<SessionQueryData>(
        queryKeys.sessions.current()
      );

      // Optimistically update
      queryClient.setQueryData<SessionQueryData | undefined>(
        queryKeys.sessions.current(),
        (old) => {
          if (!old) return undefined;
          return {
            ...old,
            data: {
              ...old.data,
              name: newData.name,
            },
          };
        }
      );

      return { previousData };
    },
    onError: (_err, _newData, context) => {
      // Rollback on error
      if (context?.previousData) {
        queryClient.setQueryData(
          queryKeys.sessions.current(),
          context.previousData
        );
      }
    },
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({
        queryKey: queryKeys.sessions.current(),
      });
    },
    errorMessage: "Failed to update profile",
  });
}
```

## Best Practices

1. **Server Components First**

   - Use server components for initial data fetching
   - Only use client queries for dynamic data needs
   - Leverage React Server Components (RSC) capabilities

2. **Type Safety**

   - Use Zod schemas for runtime validation
   - Maintain consistent types across the application
   - Leverage TypeScript for compile-time safety

3. **Error Handling**

   - Implement consistent error handling patterns
   - Use toast notifications for user feedback
   - Log errors with proper context

4. **Cache Management**

   - Set appropriate staleTime and gcTime values
   - Implement intelligent cache invalidation
   - Use optimistic updates for better UX

5. **Performance**

   - Implement data prefetching
   - Use suspense boundaries
   - Optimize re-renders with proper key usage

6. **Query Organization**

   - Centralize query keys in a dedicated config
   - Use consistent naming patterns
   - Group related queries logically

7. **Mutations**

   - Implement proper error handling
   - Use optimistic updates when appropriate
   - Handle cache invalidation consistently

8. **Testing**
   - Mock query responses in tests
   - Test error scenarios
   - Verify cache behavior

## Query Key Management

We maintain a centralized query key configuration:

```tsx
export const queryKeys = {
  sessions: {
    all: ["sessions"] as const,
    current: () => [...queryKeys.sessions.all, "current"] as const,
  },
  organizations: {
    all: ["organizations"] as const,
    list: () => [...queryKeys.organizations.all, "list"] as const,
    detail: (id: string) => [...queryKeys.organizations.all, id] as const,
  },
  // ... more query keys
};
```

## Cache Configuration

We maintain consistent cache configurations:

```tsx
export const cacheConfig = {
  queries: {
    default: {
      staleTime: 1000 * 60, // 1 minute
      gcTime: 1000 * 60 * 5, // 5 minutes
    },
    user: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 15, // 15 minutes
    },
    // ... more configurations
  },
};
```

## Next Steps

- [Error Handling](/docs/features/error-handling) - Learn about error handling patterns
- [Database](/docs/features/database) - Understand database integration
- [Authentication](/docs/features/authentication) - Auth patterns and implementation
