export const metadata = {
  title: "Query Patterns",
  description: "Common query patterns and data fetching strategies",
  section: "Features",
  order: 3,
};

# Query Patterns

Learn about common query patterns and data fetching strategies used in our Next.js 15 Boilerplate.

## Overview

We use [Tanstack Query](https://tanstack.com/query) (React Query) along with our Drizzle ORM setup for efficient data fetching and state management. This guide covers common patterns and best practices.

## Query Client Configuration

Our query client is configured with sensible defaults in `app/_providers/query-client-provider.tsx`:

```tsx
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000, // 1 minute
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});
```

## Server Components

Server components should directly use the database client for data fetching:

```tsx
// app/organizations/page.tsx
import { db } from "@/lib/db";
import { organizations } from "@/lib/db/schema";

export default async function OrganizationsPage() {
  const orgs = await db
    .select()
    .from(organizations)
    .orderBy(organizations.createdAt);

  return (
    <div>
      {orgs.map((org) => (
        <div key={org.id}>{org.name}</div>
      ))}
    </div>
  );
}
```

## Client Components

### Custom Query Hooks

We centralize query logic in custom hooks:

```tsx
// hooks/organization/use-organizations.ts
export function useOrganizations() {
  const queryClient = useQueryClient();

  // Prefetch on mount
  useEffect(() => {
    void queryClient.prefetchQuery({
      queryKey: queryKeys.organizations.list(),
      queryFn: async () => {
        const response = await getOrganizationsAction();
        if (response.error) {
          throw new Error(response.error.message);
        }
        return response.data ?? [];
      },
    });
  }, [queryClient]);

  return useQuery<Organization[]>({
    queryKey: queryKeys.organizations.list(),
    queryFn: async () => {
      const response = await getOrganizationsAction();
      if (response.error) {
        throw new Error(response.error.message);
      }
      return response.data ?? [];
    },
    staleTime: 1000 * 60,
    gcTime: 1000 * 60 * 5,
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    meta: {
      onError: (error: Error) => {
        toast.error(`Failed to load organizations: ${error.message}`);
      },
    },
  });
}
```

### Type-Safe API Queries

For API queries, we use a wrapper hook that ensures type safety:

```tsx
// lib/hooks/use-api-query.ts
export function useApiQuery<T extends z.ZodType>(
  key: readonly unknown[],
  queryFn: () => Promise<z.infer<T>>,
  schema: T,
  options?: Omit<
    UseQueryOptions<IApiResponse<z.infer<T>>>,
    "queryKey" | "queryFn"
  >
) {
  return useQuery<IApiResponse<z.infer<T>>>({
    queryKey: key,
    queryFn: async () => {
      const data = await queryFn();
      return createApiResponseSchema(schema).parse(data);
    },
    meta: {
      onError: (error: unknown) => {
        const message = isQueryError(error)
          ? error.message
          : "An unexpected error occurred";
        toast.error(message);
      },
    },
    ...options,
  });
}
```

### Mutations

Handle data mutations with proper error handling and cache updates:

```tsx
export function useCreateOrganization() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: { name: string; slug: string }) => {
      const result = await authClient.organization.create(data);
      await authClient.organization.setActive({
        organizationId: result.data?.id,
      });
      return result;
    },
    onSuccess: async () => {
      await Promise.all([
        queryClient.invalidateQueries({
          queryKey: queryKeys.organizations.all,
        }),
        queryClient.invalidateQueries({
          queryKey: queryKeys.sessions.all,
        }),
      ]);
      toast.success("Organization created successfully");
    },
    onError: (error) => {
      const message = isQueryError(error)
        ? error.message
        : "Failed to create organization";
      toast.error(message);
    },
  });
}
```

### Error Boundaries

Wrap query components with error boundaries for graceful error handling:

```tsx
export function OrganizationsWrapper() {
  return (
    <QueryErrorResetBoundary>
      {({ reset }) => (
        <ErrorBoundary
          onReset={reset}
          fallbackRender={({ resetErrorBoundary }) => (
            <div>
              Error loading organizations.
              <button onClick={resetErrorBoundary}>Try again</button>
            </div>
          )}
        >
          <OrganizationsList />
        </ErrorBoundary>
      )}
    </QueryErrorResetBoundary>
  );
}
```

## Best Practices

1. **Use Server Components First**: Prefer server components for data fetching when possible.
2. **Centralize Query Logic**: Keep query logic in custom hooks for reusability.
3. **Type Safety**: Use Zod schemas for runtime type validation.
4. **Error Handling**: Implement proper error boundaries and toast notifications.
5. **Cache Management**: Set appropriate staleTime and gcTime values.
6. **Optimistic Updates**: Use optimistic updates for better UX when appropriate.
7. **Prefetching**: Implement data prefetching for improved performance.

## Next Steps

- [Database Schema](/docs/features/database/schema) - Learn about our database schema
- [Authentication](/docs/features/authentication) - Understand auth integration
- [Error Handling](/docs/features/error-handling) - Error handling patterns
